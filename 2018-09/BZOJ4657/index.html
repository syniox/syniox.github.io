<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>[BZOJ4657] Tower - Blog | qzkszj</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0/normalize.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0/build/pure-min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0/build/grids-responsive-min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js/styles/atom-one-light.css"><style>.category-list-item{display:flex}.category-list-link{flex:1 0 auto}.category-list-count{text-align:right}.post .post-content pre code{padding:0 0}</style><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Blog | qzkszj" type="application/atom+xml"></head><body class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">[BZOJ4657] Tower</h1><a id="logo" href="/">Blog | qzkszj</a><p class="description">过往如烟。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined">Home</i></a><a href="/archives/"><i class="fa undefined"> Archive</i></a><a href="/about/"><i class="fa undefined"> About</i></a><a href="/atom.xml"><i class="fa undefined"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">[BZOJ4657] Tower</h1><div class="post-meta">September 15,2018<span> | </span><span class="category"><a href="/categories/Solution/">Solution</a></span><span> | 1.4k,5 mins.</span><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span></span><span id="busuanzi_container_page_pv"> | views: <span id="busuanzi_value_page_pv"></span></span></div><div class="tags"><a href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/">网络流</a></div><div class="post-content"><p><a target="_blank" rel="noopener" href="https://www.lydsy.com/JudgeOnline/problem.php?id=4657">BZOJ4657</a></p><p><s>炮打司令部</s><br>假如炮塔的攻击路线可以相交怎么做？<br><s>当然是直接取max。。。</s><br>也可以考虑用最小割的想法。<br>由于一个点可能被横纵向都扫一遍，所以这里考虑把点拆成横点和纵点。<br>把贡献不能共存（也就是在同一个炮塔的攻击范围）的点顺着方向连成一条链，边权设为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn><mo>−</mo></mrow><annotation encoding="application/x-tex">1000-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">−</span></span></span></span>贡献，我们会发现连成了若干条链。<br>这里就是认为每个炮塔都打满了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，然后把打每个点的代价是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn><mo>−</mo></mrow><annotation encoding="application/x-tex">1000-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">−</span></span></span></span>beta狗的数量。<br>求一遍最小割，这样就是每条链上选代价最小的点出来，再用链的数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\times 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">×</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>减去最小割就行了。<br>可以相交时样例的最小割(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mo>&gt;</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>m</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">(i,j) -&gt; (i-1)*m+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span>)：<br><img src="ignore_cross.png" alt=""></p><p>！ 以下部分需要异步阅读 ！</p><p>现在考虑不能相交的情况，根据题目我们能得到一些性质：</p><ul><li>炮塔的攻击路线上没有炮塔</li><li>只有横向和纵向的两个炮塔才有可能冲突</li></ul><p>怎么排除轨迹相交的情况？<br>网络流没法表示一个点选，另一个点就不能选<br>但是有方法表示一个点选其他点必须选（连过去不就是一种吗），可以转换</p><p>于是就可以想到染色啦<br>可以把炮塔打一个点看成选一条从炮塔到那个点的链。<br>一个割会把链和图分成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span></span></span></span>两部分，这里把割到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>集合定义为选中。<br>染色：<br>让横着的点选中表示炮弹要越过他（击中也算越过）<br>让横着的点选中表示炮弹没有越过他（击中也算越过）</p><p>定义炮击的链的部分是靠近Tower的那一边，这样的话竖的链就要转一下方向才满足染色需求。（到图里看！）<br>根据定义，竖边的权值是指向的点的权值，横边的权值是出发点的权值。<br>离炮塔最近的边（横：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>出发，竖：连向<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span></span></span></span>）设为1000，表示的是啥都不打需要的代价。</p><p>把上面的带到图中：<br><img src="cross_1.png" alt=""><br>(把图片里其他地方看成空地，两个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>点看到一起，就可以构造出地图）</p><p>现在来排除两个炮塔的轨迹经过同一个点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>的情况。<br>其实就是横<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>向竖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>连一条流量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span>的边。</p><blockquote><p>为什么不连双向边?<br>这个图本身并不对称。<br>根据前面染色的定义会有：<br>横边向竖边连<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span>的意思是(横<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>集合时，竖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>也要在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>集合)：横边经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，竖边就不能经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span><br>竖边向横边连<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span>的意思是(竖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>集合时，横<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>也要在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>集合)：竖边没经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>，横边就必须经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><br>假设竖塔割了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A,B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="mclose">)</span></span></span></span>这条边，依然会有流量从竖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>流向横<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，导致横向炮塔一定越过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，增加了不存在的限制<br>只要满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span></span></span></span>选时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">b</span></span></span></span>不选，就能满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">b</span></span></span></span>不能同时选的条件。</p></blockquote><p>这时如果横向的炮经过了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>的话，竖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>一定会被归到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>集合（横<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span>不可被切断）<br>那就意味着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>到竖炮台(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span></span></span></span>)一定要有东西被切断，也就是说竖炮的轨迹不到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span><br>根据最小割,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>和以上的部分也不会再被割。<br>这样就说明只要横的轨迹经过交点，竖塔的轨迹就不会再碰那个交点，保证不会有相交。<br>满足限制，保证最优，跑最小割就好了。</p><p><a target="_blank" rel="noopener" href="https://github.com/syniox/Online_Judge_solutions/blob/master/BZOJ/4657.cpp">code</a>:</p><pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2502</span>,M=<span class="hljs-number">52</span>;
<span class="hljs-type">int</span> n,m,sum,fir[N&lt;&lt;<span class="hljs-number">1</span>],cur[N&lt;&lt;<span class="hljs-number">1</span>],dep[N&lt;&lt;<span class="hljs-number">1</span>],mp[M][M];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;
	<span class="hljs-type">int</span> to,wi,nx;
&#125;eg[N*<span class="hljs-number">6</span>];

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">nxi</span><span class="hljs-params">()</span></span>&#123;
	<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;
	<span class="hljs-type">char</span> c;
	<span class="hljs-keyword">while</span>(((c=<span class="hljs-built_in">getchar</span>())&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&amp;&amp;c!=<span class="hljs-string">&#x27;-&#x27;</span>);
	<span class="hljs-type">const</span> <span class="hljs-type">bool</span> f=c==<span class="hljs-string">&#x27;-&#x27;</span>;
	f&amp;&amp;(c=<span class="hljs-built_in">getchar</span>());
	<span class="hljs-keyword">while</span>(x=x*<span class="hljs-number">10</span><span class="hljs-number">-48</span>+c,(c=<span class="hljs-built_in">getchar</span>())&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>);
	<span class="hljs-keyword">return</span> f?-x:x;
&#125;

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a,<span class="hljs-type">const</span> <span class="hljs-type">int</span> b,<span class="hljs-type">const</span> <span class="hljs-type">int</span> v)</span></span>&#123;
	<span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;
	eg[++cnt]=(edge)&#123;b,v,fir[a]&#125;;
	fir[a]=cnt;
	eg[++cnt]=(edge)&#123;a,<span class="hljs-number">0</span>,fir[b]&#125;;
	fir[b]=cnt;
&#125;

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> x,<span class="hljs-type">const</span> <span class="hljs-type">int</span> y)</span></span>&#123;
	<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> cx[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,cy[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;
	<span class="hljs-type">const</span> <span class="hljs-type">int</span> fx=-mp[x][y];
	<span class="hljs-keyword">if</span>(fx&lt;=<span class="hljs-number">2</span>)&#123;
		<span class="hljs-type">int</span> tx=fx==<span class="hljs-number">1</span>?<span class="hljs-number">1</span>:n;
		<span class="hljs-keyword">if</span>(tx==x) <span class="hljs-keyword">return</span>;
		<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>,(tx<span class="hljs-number">-1</span>)*m+y+N,<span class="hljs-number">1000</span>-mp[tx][y]);
		<span class="hljs-keyword">for</span>(;tx-cx[fx]!=x;tx-=cx[fx])&#123;
			<span class="hljs-built_in">add</span>((tx<span class="hljs-number">-1</span>)*m+y+N,(tx-cx[fx]<span class="hljs-number">-1</span>)*m+y+N,<span class="hljs-number">1000</span>-mp[tx-cx[fx]][y]);
		&#125;
		<span class="hljs-built_in">add</span>((tx<span class="hljs-number">-1</span>)*m+y+N,(N&lt;&lt;<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>,<span class="hljs-number">1000</span>);
	&#125;
	<span class="hljs-keyword">else</span>&#123;
		<span class="hljs-type">const</span> <span class="hljs-type">int</span> px=(x<span class="hljs-number">-1</span>)*m;
		<span class="hljs-type">int</span> ty=y+cy[fx];
		<span class="hljs-keyword">if</span>(!ty||ty&gt;m) <span class="hljs-keyword">return</span>;
		<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>,px+ty,<span class="hljs-number">1000</span>);
		<span class="hljs-keyword">for</span>(;ty&gt;<span class="hljs-number">1</span>&amp;&amp;ty&lt;m;ty+=cy[fx])&#123;
			<span class="hljs-built_in">add</span>(px+ty,px+ty+cy[fx],<span class="hljs-number">1000</span>-mp[x][ty]);
		&#125;
		<span class="hljs-built_in">add</span>(px+ty,(N&lt;&lt;<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>,<span class="hljs-number">1000</span>-mp[x][ty]);
	&#125;
	sum+=<span class="hljs-number">1000</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">dinic_bfs</span><span class="hljs-params">()</span></span>&#123;
	<span class="hljs-type">static</span> <span class="hljs-type">int</span> que[N&lt;&lt;<span class="hljs-number">1</span>];
	<span class="hljs-type">int</span> hd=<span class="hljs-number">0</span>,tl=<span class="hljs-number">1</span>;
	<span class="hljs-built_in">memset</span>(dep,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dep));
	dep[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(hd!=tl)&#123;
		<span class="hljs-type">const</span> <span class="hljs-type">int</span> x=que[hd++];
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cur[x]=fir[x];i;i=eg[i].nx)&#123;
			<span class="hljs-type">const</span> <span class="hljs-type">int</span> y=eg[i].to;
			<span class="hljs-keyword">if</span>(eg[i].wi&amp;&amp;!dep[y])&#123;
				dep[y]=dep[x]+<span class="hljs-number">1</span>;
				que[tl++]=y;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> dep[(N&lt;&lt;<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>];
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic_dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> x,<span class="hljs-type">const</span> <span class="hljs-type">int</span> t)</span></span>&#123;
	<span class="hljs-keyword">if</span>(x==(N&lt;&lt;<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> t;
	<span class="hljs-type">int</span> tt=t,tp;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;i=cur[x];i;i=eg[i].nx)&#123;
		<span class="hljs-type">const</span> <span class="hljs-type">int</span> y=eg[i].to,v=eg[i].wi;
		<span class="hljs-keyword">if</span>(dep[y]==dep[x]+<span class="hljs-number">1</span>&amp;&amp;v&amp;&amp;(tp=<span class="hljs-built_in">dinic_dfs</span>(y,std::<span class="hljs-built_in">min</span>(v,tt))))&#123;
			eg[i].wi-=tp;
			eg[i^<span class="hljs-number">1</span>].wi+=tp;
			tt-=tp;
			<span class="hljs-keyword">if</span>(!tt) <span class="hljs-keyword">break</span>;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> t-tt;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ONLINE_JUDGE</span>
<span class="hljs-comment">//	freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
	n=<span class="hljs-built_in">nxi</span>(),m=<span class="hljs-built_in">nxi</span>();
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)&#123;
			mp[i][j]=<span class="hljs-built_in">nxi</span>();
		&#125;
	&#125;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)&#123;
			<span class="hljs-keyword">if</span>(mp[i][j]&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">build</span>(i,j);
			<span class="hljs-keyword">else</span>&#123;
				<span class="hljs-type">const</span> <span class="hljs-type">int</span> cur=(i<span class="hljs-number">-1</span>)*m+j;
				<span class="hljs-built_in">add</span>(cur,cur+N,<span class="hljs-number">1e8</span>);
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">dinic_bfs</span>()) sum-=<span class="hljs-built_in">dinic_dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1e8</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div><div class="page-navigator"><a class="pre" href="/2018-10/AGC012E/">Previous</a><a class="next" href="/2018-08/matrix/">Next</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title">Categories</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Note/">Note</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Recollections/">Recollections</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Solution/">Solution</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Starred/">Starred</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title">Tags</div><div class="tagcloud"><a href="/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" style="font-size:15px">组合数学</a> <a href="/tags/DP-%E4%BC%98%E5%8C%96/" style="font-size:15px">DP/优化</a> <a href="/tags/%E6%95%B0%E8%AE%BA/" style="font-size:16px">数论</a> <a href="/tags/%E5%AE%B9%E6%96%A5/" style="font-size:13px">容斥</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size:13px">集合</a> <a href="/tags/%E5%81%8F%E5%BA%8F/" style="font-size:13px">偏序</a> <a href="/tags/%E6%A0%91/" style="font-size:13px">树</a> <a href="/tags/%E6%8B%93%E6%89%91/" style="font-size:13px">拓扑</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" style="font-size:14px">网络流</a> <a href="/tags/%E7%BB%93%E8%AE%BA/" style="font-size:13px">结论</a> <a href="/tags/%E7%BE%A4%E8%AE%BA/" style="font-size:13px">群论</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:13px">字符串</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size:13px">线性代数</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size:13px">矩阵</a> <a href="/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/" style="font-size:14px">多项式</a> <a href="/tags/%E6%94%AF%E9%85%8D%E6%A0%91/" style="font-size:13px">支配树</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size:14px">图论</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size:13px">数学</a></div></div><div class="widget"><div class="widget-title">Links</div><ul class="links-list"><li class="links-list-item"><a href="https://cnblogs.com/dedicatus545" title="dedicatus545" target="_blank">dedicatus545</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="https://blog.sshockwave.net" title="sshockwave" target="_blank">sshockwave</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="https://www.cnblogs.com/dcdcbigbig/" title="DCDCbigbig" target="_blank">DCDCbigbig</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="https://www.cnblogs.com/JackyhhJuRuo/" title="Jackyhh" target="_blank">Jackyhh</a></li></ul></div></div></div></div><div id="footer">© <a href="/" real="nofollow">Blog | qzkszj.</a><i> Powered by </i><a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a></div></body></html>